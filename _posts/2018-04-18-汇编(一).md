---
title: 汇编(一)

layout: post

tags: 汇编

---

## 总线:
* 数据总线:
	* 决定了CPU的单词数据传输量(数据吞吐量),也就是数据传输速度
	* 8086的数据总线的宽度是16,所以单次最大传输量为2字节
* 地址总线:

	* 决定寻址能力(8086 20个线脚 2<sup>20</sup>  **1M**)

* 控制总线:
	* 宽度决定对其他控件的控制能力,能有多少种控制

	
	
## ARM64
* arm64拥有31个64位通用寄存器(x0~x30)
* w0~w28 是x0的低32位


## PC寄存器(Program counter)
指向下一条将要执行的指令

## BL指令
bl指令(即8086中的call指令)

* move x0,#10, mov x01,#20(#10,#20 立即数,即常数)

## 汇编初探实战
* 在新建的xcode项目中,添加一个汇编文件
	![](https://ws2.sinaimg.cn/large/006tKfTcly1fqh7z2gslxj314m0tajux.jpg)
* 建立好的汇编文件如下图:

	![](https://ws4.sinaimg.cn/large/006tKfTcly1fqh7zwdy0jj31kw0qdwkb.jpg)
* 在first.s文件中,开始编写我们的初探汇编代码😁
	![](https://ws3.sinaimg.cn/large/006tKfTcgy1fqh88f1ecbj31kw0us49s.jpg)

* 回到main.c中,调用刚才编写的汇编A函数( ⊙ o ⊙ )！可是马上发现问题了,xCode竟然报错
	![](https://ws3.sinaimg.cn/large/006tKfTcgy1fqh8cdk01zj31c60xyn0b.jpg)
> 这是因为我们并没有对这个函数进行声明,编译器找不到A方法而报错,其实本质上,代码是木有问题的,我们只需要声明一下A函数即可

	![](https://ws3.sinaimg.cn/large/006tKfTcly1fqh8f90ai2j31c612wwk8.jpg)
> 接下来我们就要一步一步开始利用xCode研究咯,在A函数处打上断点,方便我们查看寄存器

> **注意:**需要用真机来调试,因为模拟器(x86)和真机(arm64)的指令集不同,会报错~~切记用真机


* 要修改如下模式,才能看到我们滴汇编调试代码以及各个寄存器
	![](https://ws4.sinaimg.cn/large/006tKfTcgy1fqh8k5ot3oj31kw15faun.jpg)

	修改后的样式如下,有点高大上了哦😀
	![](https://ws1.sinaimg.cn/large/006tKfTcly1fqh8lr3cz7j31kw11c7in.jpg)
	* 打断点处,即可看到下一条指令就是bl到一处内存地址我们可以在lldb中键入**lldb命令**标注的命令,s跳入函数
	 ![](https://ws3.sinaimg.cn/large/006tKfTcgy1fqh8sodypaj31ca15g7da.jpg)
	* 可以看到程序已经按照我们的期望做出了变化
	 ![](https://ws1.sinaimg.cn/large/006tKfTcgy1fqh8vqaunwj31c513u7eg.jpg)
	* 当遇到ret后,会回到调用处
	![](https://ws4.sinaimg.cn/large/006tKfTcgy1fqh8x94n1xj31c610m79h.jpg)
	* 回到了A方法
	![](https://ws4.sinaimg.cn/large/006tKfTcgy1fqh8yrd63dj31by0xkq89.jpg)
	* 再次单步执行,就会结束当前函数回到main.c中了哦

---

## lldb指令
* ni 单步执行指令
* s 跳入函数
* memery read  
* rigister write pc 内存地址