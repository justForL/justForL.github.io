---
title: 汇编(一)

layout: post

tags: 汇编

---

## 汇编语言的发展
### 机器语言
> 由0和1组成的机器指令.

* 加：0100 0000
* 减：0100 1000
* 乘：1111 0111 1110 0000 
* 除：1111 0111 1111 0000 

### 汇编语言(assembly language)
> 使用助记符代替机器语言
> 如:

* 加：INC EAX		通过编译器 0100 0000
* 减：DEC EAX		通过编译器 0100 1000
* 乘：MUL EAX 		通过编译器 1111 0111 1110 0000
* 除：DIV EAX		通过编译器 1111 0111 1111 0000

### 高级语言（High-level programming language)
>C\C++\Java\OC\Swift,更加接近人类的自然语言
>比如C语言:

* 加：A+B		通过编译器			0100 0000
* 减：A-B		通过编译器			0100 1000
* 乘：A*B 	通过编译器			1111 0111 1110 0000
* 除：A/B		通过编译器			1111 0111 1111 0000


我们的代码在终端设备上是这样的过程:

![](https://ws2.sinaimg.cn/large/006tNc79ly1fqhszr1fqdj30iy03k3yt.jpg)

### 汇编语言的特点
* 可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能

* 能够不受编译器的限制，对生成的二进制代码进行完全的控制

* 目标代码简短，占用内存少，执行速度快

* 汇编指令是机器指令的助记符,同机器指令一一对应。每一种CPU都有自己的机器指令集\汇编指令集，所以汇编语言不具备可移植性


* 知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护

* 不区分大小写，比如mov和MOV是一样的



### 需要注意:
*  **汇编语言**与**机器语言**一一对应，每一条机器指令都有与之对应的汇编指令


*  **汇编语言**可以通过编译得到**机器语言**，**机器语言**可以通过反汇编得到**汇编语言**


*  **高级语言**可以通过编译得到**汇编语言** \ **机器语言**，但汇编语言\机器语言几乎不可能还原成**高级语言**

### 汇编语言的种类
* 目前讨论比较多的汇编语言有
  * 8086汇编（8086处理器是16bit的CPU）
  * Win32汇编
  * Win64汇编
  * ARM汇编（嵌入式、Mac、iOS）
  * ......

* 我们iPhone里面用到的是ARM汇编,但是不同的设备也有差异.因CPU的架构不同.

架构 | 设备 
----|------
armv6 | iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch
armv7 | iPhone3GS, iPhone4, iPhone4S,iPad, iPad2, iPad3(The New iPad), iPad mini, iPod Touch 3G, iPod Touch4
armv7s |iPhone5, iPhone5C, iPad4(iPad with Retina Display)
arm64 | iPhone5S 以后 iPhoneX , iPad Air, iPad mini2以后

### App的执行过程
![](https://ws4.sinaimg.cn/large/006tNc79ly1fqht6gg0z3j30l304i74p.jpg)


##进制
**学习进制的障碍**
> 很多人学不好进制，原因是总以十进制为依托去考虑其他进制，需要运算的时候也总是先转换成十进制，这种学习方法是错误的.
> 我们为什么一定要转换十进制呢？仅仅是因为我们对十进制最熟悉，所以才转换.
> 每一种进制都是完美的,想学好进制首先要忘掉十进制，也要忘掉进制间的转换！

### 进制的定义
* 八进制由8个符号组成:0 1 2 3 4 5 6 7 逢八进一
* 十进制由10个符号组成:0 1 2 3 4 5 6 7 8 9逢十进一
* N进制就是由N个符号组成:逢N进一


##### 做个练习
* 1 + 1 在____情况下等于 3 ?

```思考
.
.
.
.
.
.
.
.
.
.
.
.
.
```

> 十进制由10个符号组成: 0 1 3 2 8 A B E S 7 逢十进一

如果这样定义十进制: 1 + 1 = 3!就对了!

**这样的目的何在?**
传统我们定义的十进制和自定义的十进制不一样.那么这10个符号如果我们不告诉别人这个符号表,别人是没办法拿到我们的具体数据的!用于加密!

>**十进制**由十个**符号**组成,逢十进一,**符号**是可以**自定义**的!!

### 进制的运算

##### 做个练习
* 八进制运算
	* 2 + 3 = __ , 2 * 3 = __ ,4 + 5 = __ ,4 * 5 = __.
	* 277 + 333 = __ , 276 * 54 = __ , 237 - 54 = __ , 234 / 4 = __ .
	
	

	

##### 八进制加法表
```
 0  1  2  3  4  5  6  7 
10 11 12 13 14 15 16 17
20 21 22 23 24 25 26 27
...

1+1 = 2						
1+2 = 3   2+2 = 4				
1+3 = 4   2+3 = 5   3+3 = 6
1+4 = 5   2+4 = 6   3+4 = 7   4+4 = 10  
1+5 = 6   2+5 = 7   3+5 = 10  4+5 = 11  5+5 = 12
1+6 = 7   2+6 = 10  3+6 = 11  4+6 = 12  5+6 = 13  6+6 = 14
1+7 = 10  2+7 = 11  3+7 = 12  4+7 = 13  5+7 = 14  6+7 = 15  7+7 = 16
```

##### 八进制乘法表
```
0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27...
1*1 = 1						
1*2 = 2	  2*2 = 4				
1*3 = 3	  2*3 = 6	3*3 = 11	
1*4 = 4	  2*4 = 10	3*4 = 14  4*4 = 20
1*5 = 5	  2*5 = 12	3*5 = 17  4*5 = 24  5*5 = 31
1*6 = 6	  2*6 = 14	3*6 = 22  4*6 = 30  5*6 = 36  6*6 = 44
1*7 = 7	  2*7 = 16	3*7 = 25  4*7 = 34  5*7 = 43  6*7 = 52  7*7 = 61
```
##### 实战四则运算
```
   277         236         276         234
+  333       -  54       *  54       /   4
--------    --------    --------    --------    
```



### 二进制的简写形式
```
       二进制: 1 0 1 1 1 0 1 1 1 1 0 0
三个二进制一组: 101 110 111 100
       八进制:   5   6   7   4
四个二进制一组: 1011 1011 1100
     十六进制:    b    b    c
```
> 二进制：从0 写到 1111
> 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 
> 这种二进制使用起来太麻烦，改成更简单一点的符号：
> 0 1 2 3 4 5 6 7 8 9 A B C D E F 这就是十六进制了



## 总线:
* 数据总线:
	* 决定了CPU的单词数据传输量(数据吞吐量),也就是数据传输速度
	* 8086的数据总线的宽度是16,所以单次最大传输量为2字节
* 地址总线:

	* 决定寻址能力(8086 20个线脚 2<sup>20</sup>  **1M**)

* 控制总线:
	* 宽度决定对其他控件的控制能力,能有多少种控制

### 练习题
* 一个CPU 的寻址能力为8KB,那么它的地址总线的宽度为\_\_\_\_


* 8080,8088,80286,80386 的**地址总线**宽度分别为16根,20根,24根,32根.那么他们的寻址能力分别为多少\_\_\_\_KB, \_\_\_\_MB,\_\_\_\_MB,\_\_\_\_GB?


* 8080,8088,8086,80286,80386 的**数据总线**宽度分别为8根,8根,16根,16根,32根.那么它们一次可以传输的数据为:\_\_\_\_B,\_\_\_\_B,\_\_\_\_B,\_\_\_\_B,\_\_\_\_B,


* 从内存中读取1024字节的数据,8086至少要读\_\_\_\_次,80386至少要读取\_\_\_\_次.

**答案**

![练习](http://upload-images.jianshu.io/upload_images/2990730-c9eddd9d28a8cb42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
	
## ARM64
* arm64拥有31个64位通用寄存器(x0~x30)
* w0~w28 是x0的低32位


## PC寄存器(Program counter)
指向下一条将要执行的指令

## BL指令
bl指令(即8086中的call指令)

* move x0,#10, mov x01,#20(#10,#20 立即数,即常数)

## 汇编初探实战
* 在新建的xcode项目中,添加一个汇编文件
	![](https://ws2.sinaimg.cn/large/006tKfTcly1fqh7z2gslxj314m0tajux.jpg)
* 建立好的汇编文件如下图:

	![](https://ws4.sinaimg.cn/large/006tKfTcly1fqh7zwdy0jj31kw0qdwkb.jpg)
* 在first.s文件中,开始编写我们的初探汇编代码😁
	![](https://ws3.sinaimg.cn/large/006tKfTcgy1fqh88f1ecbj31kw0us49s.jpg)

* 回到main.c中,调用刚才编写的汇编A函数( ⊙ o ⊙ )！可是马上发现问题了,xCode竟然报错
	![](https://ws3.sinaimg.cn/large/006tKfTcgy1fqh8cdk01zj31c60xyn0b.jpg)
> 这是因为我们并没有对这个函数进行声明,编译器找不到A方法而报错,其实本质上,代码是木有问题的,我们只需要声明一下A函数即可

	![](https://ws3.sinaimg.cn/large/006tKfTcly1fqh8f90ai2j31c612wwk8.jpg)
> 接下来我们就要一步一步开始利用xCode研究咯,在A函数处打上断点,方便我们查看寄存器

> **注意:**需要用真机来调试,因为模拟器(x86)和真机(arm64)的指令集不同,会报错~~切记用真机


* 要修改如下模式,才能看到我们滴汇编调试代码以及各个寄存器
	![](https://ws4.sinaimg.cn/large/006tKfTcgy1fqh8k5ot3oj31kw15faun.jpg)

	修改后的样式如下,有点高大上了哦😀
	![](https://ws1.sinaimg.cn/large/006tKfTcly1fqh8lr3cz7j31kw11c7in.jpg)
	* 打断点处,即可看到下一条指令就是bl到一处内存地址我们可以在lldb中键入**lldb命令**标注的命令,s跳入函数
	 ![](https://ws3.sinaimg.cn/large/006tKfTcgy1fqh8sodypaj31ca15g7da.jpg)
	* 可以看到程序已经按照我们的期望做出了变化
	 ![](https://ws1.sinaimg.cn/large/006tKfTcgy1fqh8vqaunwj31c513u7eg.jpg)
	* 当遇到ret后,会回到调用处
	![](https://ws4.sinaimg.cn/large/006tKfTcgy1fqh8x94n1xj31c610m79h.jpg)
	* 回到了A方法
	![](https://ws4.sinaimg.cn/large/006tKfTcgy1fqh8yrd63dj31by0xkq89.jpg)
	* 再次单步执行,就会结束当前函数回到main.c中了哦

---

## lldb指令
* ni 单步执行指令
* s 跳入函数
* memery read  
* rigister write pc 内存地址